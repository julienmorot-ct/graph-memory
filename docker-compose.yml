# =============================================================================
# MCP Memory Service - Docker Compose (Sécurisé)
# =============================================================================
# Démarrage : docker compose up -d
# Logs      : docker compose logs -f mcp-memory
# Logs WAF  : docker compose logs -f waf
# Arrêt     : docker compose down
# =============================================================================
#
# Architecture réseau :
#
#   Internet/LAN
#       │
#       ▼ :8080 (seul port exposé)
#   ┌──────────┐
#   │ Coraza   │  WAF OWASP CRS + Reverse Proxy + Security Headers
#   │ WAF      │
#   └────┬─────┘
#        │ réseau interne Docker (mcp-network)
#        ▼
#   ┌──────────┐
#   │ MCP      │  Service principal :8002 (interne uniquement)
#   │ Memory   │
#   └────┬─────┘
#        │
#   ┌────┴────┐
#   ▼         ▼
# Neo4j    Qdrant    (aucun port exposé, réseau interne uniquement)
#
# =============================================================================

services:
  # ===========================================================================
  # Coraza WAF - Web Application Firewall (reverse proxy sécurisé)
  # ===========================================================================
  # Image : Caddy + Coraza WAF + OWASP Core Rule Set (CRS)
  # Doc   : https://github.com/corazawaf/coraza-crs-docker
  # ===========================================================================
  waf:
    build: ./waf
    container_name: mcp-memory-waf
    ports:
      # --- Mode DEV (HTTP) ---
      - "${WAF_PORT:-8080}:8080"
      # --- Mode PROD (HTTPS + Let's Encrypt) ---
      # Décommenter les 2 lignes suivantes et commenter la ligne WAF_PORT ci-dessus :
      # - "80:80"     # Redirect HTTP → HTTPS + challenge ACME Let's Encrypt
      # - "443:443"   # HTTPS (TLS automatique via Let's Encrypt)
    environment:
      # Adresse d'écoute du site :
      # - Dev  : ":8080"                       (HTTP, pas de TLS)
      # - Prod : "graph-memory.mon-domaine.com" (HTTPS automatique Let's Encrypt)
      - SITE_ADDRESS=${SITE_ADDRESS:-:8080}
      # Backend à protéger
      - BACKEND=mcp-memory:8002
      - BACKEND_PROTOCOL=http
      # Mode du WAF : "On" = bloque, "DetectionOnly" = log sans bloquer
      - ANOMALY_INBOUND=5
      - ANOMALY_OUTBOUND=4
      - REPORTING_LEVEL=2
      # Taille max des requêtes (pour supporter l'upload de documents en base64)
      - ALLOWED_REQUEST_CONTENT_TYPE=|application/json|text/plain|multipart/form-data|application/x-www-form-urlencoded|application/octet-stream|
      # Augmenter la limite de body pour les ingestions (50MB en base64 ≈ 70MB encodé)
      - MAX_REQUEST_BODY_SIZE=75000000
      - MAX_REQUEST_BODY_NOFILES=75000000
      - CRS_ENABLE_BODY_INSPECTION=1
    volumes:
      - ./waf/Caddyfile:/etc/caddy/Caddyfile:ro
      - waf_data:/data # Certificats TLS Let's Encrypt stockés ici
      - waf_config:/config
    depends_on:
      mcp-memory:
        condition: service_started
    restart: unless-stopped
    networks:
      - mcp-network

  # ===========================================================================
  # MCP Memory Service - Serveur principal (interne uniquement)
  # ===========================================================================
  mcp-memory:
    build: .
    container_name: mcp-memory-service
    # NOTE: Pas de section "ports:" — accessible uniquement via le WAF
    # Pour le debug local, décommenter :
    # ports:
    #   - "127.0.0.1:8002:8002"
    environment:
      # Neo4j
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=${NEO4J_USER:-neo4j}
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      # S3
      - S3_ENDPOINT_URL=${S3_ENDPOINT_URL}
      - S3_ACCESS_KEY_ID=${S3_ACCESS_KEY_ID}
      - S3_SECRET_ACCESS_KEY=${S3_SECRET_ACCESS_KEY}
      - S3_BUCKET_NAME=${S3_BUCKET_NAME}
      # LLMaaS
      - LLMAAS_API_URL=${LLMAAS_API_URL}
      - LLMAAS_API_KEY=${LLMAAS_API_KEY}
      - LLMAAS_MODEL=${LLMAAS_MODEL:-gpt-oss:120b}
      # Extraction : défauts dans config.py (950K max text, 25K chunk size)
      # Décommenter pour surcharger :
      # - EXTRACTION_MAX_TEXT_LENGTH=${EXTRACTION_MAX_TEXT_LENGTH:-950000}
      # - EXTRACTION_CHUNK_SIZE=${EXTRACTION_CHUNK_SIZE:-25000}
      # Embedding
      - LLMAAS_EMBEDDING_MODEL=${LLMAAS_EMBEDDING_MODEL:-bge-m3:567m}
      - LLMAAS_EMBEDDING_DIMENSIONS=${LLMAAS_EMBEDDING_DIMENSIONS:-1024}
      # Qdrant
      - QDRANT_URL=http://qdrant:6333
      - QDRANT_COLLECTION_PREFIX=${QDRANT_COLLECTION_PREFIX:-memory_}
      # Chunking
      - CHUNK_SIZE=${CHUNK_SIZE:-500}
      - CHUNK_OVERLAP=${CHUNK_OVERLAP:-50}
      # Server config
      - MCP_SERVER_DEBUG=${MCP_SERVER_DEBUG:-false}
      - ADMIN_BOOTSTRAP_KEY=${ADMIN_BOOTSTRAP_KEY}
    healthcheck:
      # /sse est un endpoint SSE (streaming infini) : curl reçoit le HTTP 200 puis
      # timeout car le flux ne se ferme jamais → exit code 28.
      # On accepte exit 0 (succès) OU exit 28 (timeout après connexion réussie) = healthy.
      test:
        [
          "CMD-SHELL",
          "curl -sf http://localhost:8002/sse --max-time 2 -o /dev/null 2>/dev/null; rc=$$?; [ $$rc -eq 0 ] || [ $$rc -eq 28 ]",
        ]
      interval: 30s
      timeout: 10s
      start_period: 10s
      retries: 3
    depends_on:
      neo4j:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      minio:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - mcp-network

  # ===========================================================================
  # Neo4j - Base de données graphe (interne uniquement)
  # ===========================================================================
  neo4j:
    image: neo4j:5-community
    container_name: mcp-memory-neo4j
    # NOTE: Pas de section "ports:" — accessible uniquement via mcp-network
    # Pour le debug local, décommenter :
    # ports:
    #   - "127.0.0.1:7475:7474"
    #   - "127.0.0.1:7688:7687"
    environment:
      - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD}
      # Configuration mémoire (ajuster selon vos ressources)
      - NEO4J_server_memory_heap_initial__size=512m
      - NEO4J_server_memory_heap_max__size=1G
      - NEO4J_server_memory_pagecache_size=512m
      # Plugins (APOC pour fonctions avancées)
      - NEO4J_PLUGINS=["apoc"]
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "wget --no-verbose --tries=1 --spider http://localhost:7474 || exit 1",
        ]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 30s
    restart: unless-stopped
    networks:
      - mcp-network

  # ===========================================================================
  # MinIO - Stockage objet S3-compatible (local dev, interne uniquement)
  # ===========================================================================
  minio:
    image: minio/minio:latest
    container_name: mcp-memory-minio
    # NOTE: Pas de section "ports:" — accessible uniquement via mcp-network
    # Pour le debug local (console web + API), décommenter :
    # ports:
    #   - "127.0.0.1:9000:9000"   # S3 API
    #   - "127.0.0.1:9001:9001"   # Console Web (http://localhost:9001)
    environment:
      - MINIO_ROOT_USER=${S3_ACCESS_KEY_ID:-minioadmin}
      - MINIO_ROOT_PASSWORD=${S3_SECRET_ACCESS_KEY:-minioadmin}
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "mc", "ready", "local"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
    restart: unless-stopped
    networks:
      - mcp-network

  # ===========================================================================
  # MinIO Init - Création automatique du bucket
  # ===========================================================================
  minio-init:
    image: minio/mc:latest
    container_name: mcp-memory-minio-init
    depends_on:
      minio:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      mc alias set local http://minio:9000 $${S3_ACCESS_KEY_ID} $${S3_SECRET_ACCESS_KEY};
      mc mb --ignore-existing local/$${S3_BUCKET_NAME};
      echo 'Bucket $${S3_BUCKET_NAME} is ready';
      exit 0;
      "
    environment:
      - S3_ACCESS_KEY_ID=${S3_ACCESS_KEY_ID:-minioadmin}
      - S3_SECRET_ACCESS_KEY=${S3_SECRET_ACCESS_KEY:-minioadmin}
      - S3_BUCKET_NAME=${S3_BUCKET_NAME:-mcp-memory-docs}
    networks:
      - mcp-network

  # ===========================================================================
  # Qdrant - Base de données vectorielle (interne uniquement)
  # ===========================================================================
  qdrant:
    image: qdrant/qdrant:v1.16.2
    container_name: mcp-memory-qdrant
    # NOTE: Pas de section "ports:" — accessible uniquement via mcp-network
    # Pour le debug local, décommenter :
    # ports:
    #   - "127.0.0.1:6333:6333"
    volumes:
      - qdrant_data:/qdrant/storage
    healthcheck:
      test: ["CMD-SHELL", "bash -c 'echo > /dev/tcp/localhost/6333'"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 5s
    restart: unless-stopped
    networks:
      - mcp-network

# =============================================================================
# Volumes persistants
# =============================================================================
volumes:
  neo4j_data:
    name: mcp-memory-neo4j-data
  neo4j_logs:
    name: mcp-memory-neo4j-logs
  qdrant_data:
    name: mcp-memory-qdrant-data
  minio_data:
    name: mcp-memory-minio-data
  waf_data:
    name: mcp-memory-waf-data
  waf_config:
    name: mcp-memory-waf-config

# =============================================================================
# Réseau
# =============================================================================
networks:
  mcp-network:
    name: mcp-memory-network
    driver: bridge
